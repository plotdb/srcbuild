// Generated by LiveScript 1.6.0
var fs, path, fsExtra, pug, livescript, stylus, jsYaml, marked, base, aux, adapter, pugbuild;
fs = require('fs');
path = require('path');
fsExtra = require('fs-extra');
pug = require('pug');
livescript = require('livescript');
stylus = require('stylus');
jsYaml = require('js-yaml');
marked = require('marked');
base = require('./base');
aux = require('../aux');
adapter = require('../adapter');
pugbuild = function(opt){
  opt == null && (opt = {});
  this.init(import$({
    srcdir: 'src/pug',
    desdir: 'static'
  }, opt));
  this.i18n = opt.i18n || null;
  this.intlbase = opt.intlbase || 'intl';
  this.viewdir = path.normalize(path.join(this.base, opt.viewdir || '.view'));
  this.extapi = this.getExtapi();
  return this;
};
pugbuild.prototype = import$(Object.create(base.prototype), {
  resolve: function(fn, src, opt){
    var des, e;
    if (!/^@/.exec(fn)) {
      return path.resolve(path.join(path.dirname(src), fn));
    }
    try {
      if (/^@\//.exec(fn)) {
        return require.resolve(fn.replace(/^@\//, ""));
      } else if (/^@static\//.exec(fn)) {
        des = "/" + path.join(this.srcdir.split('/').filter(function(it){
          return it;
        }).map(function(){
          return '..';
        }).join('/'), this.desdir);
        return path.resolve(path.join(path.dirname(src), fn.replace(/^@static/, des)));
      }
    } catch (e$) {
      e = e$;
      throw new Error("no such file or directory: " + fn);
    }
  },
  getExtapi: function(){
    var this$ = this;
    return {
      plugins: [{
        resolve: function(){
          var args, res$, i$, to$;
          res$ = [];
          for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
            res$.push(arguments[i$]);
          }
          args = res$;
          return this$.resolve.apply(this$, args);
        }
      }],
      filters: {
        'lsc': function(text, opt){
          return livescript.compile(text, {
            bare: true,
            header: false
          });
        },
        'lson': function(text, opt){
          return livescript.compile(text, {
            bare: true,
            header: false,
            json: true
          });
        },
        'stylus': function(text, opt){
          return stylus(text).set('filename', 'inline').define('index', function(a, b){
            a = (a.string || a.val).split(' ');
            return new stylus.nodes.Unit(a.indexOf(b.val));
          }).render();
        },
        'md': function(text, opt){
          return marked(text);
        }
      },
      md: marked,
      yaml: function(it){
        return jsYaml.safeLoad(fs.readFileSync(it));
      },
      yamls: function(dir){
        var ret;
        ret = fs.readdirSync(dir).map(function(it){
          return dir + "/" + it;
        }).filter(function(it){
          return /\.yaml$/.exec(it);
        }).map(function(it){
          var e;
          try {
            return jsYaml.safeLoad(fs.readFileSync(it));
          } catch (e$) {
            e = e$;
            return console.log("[ERROR@" + it + "]: ", e);
          }
        });
        return ret;
      }
    };
  },
  getDependencies: function(file){
    var code, ret, root;
    code = fs.readFileSync(file);
    ret = pug.compileClientWithDependenciesTracked(code, import$({
      basedir: path.join(path.dirname(file)),
      filename: file
    }, this.extapi));
    root = path.resolve('.') + '/';
    return (ret.dependencies || []).map(function(it){
      return it.replace(root, '');
    });
  },
  isSupported: function(file){
    return /\.pug$/.exec(file) && file.startsWith(this.srcdir);
  },
  build: function(files){
    var _, lngs, ref$, consume, this$ = this;
    _ = function(lng){
      var intl, p, that, ref$;
      lng == null && (lng = '');
      intl = lng ? path.join(this$.intlbase, lng) : '';
      p = this$.i18n && this$.i18n.changeLanguage
        ? this$.i18n.changeLanguage((that = lng)
          ? that
          : ((ref$ = this$.i18n).options || (ref$.options = {})).fallbackLng)
        : Promise.resolve();
      return p.then(function(){
        var i$, ref$, len$, ref1$, file, mtime, src, desh, desv, code, t1, desvdir, ret, t2, desdir, e, results$ = [];
        for (i$ = 0, len$ = (ref$ = files).length; i$ < len$; ++i$) {
          ref1$ = ref$[i$], file = ref1$.file, mtime = ref1$.mtime;
          src = file;
          desh = src.replace(this$.srcdir, this$.desdir).replace(/.pug$/, '.html');
          desv = desh.replace(this$.desdir, this$.viewdir).replace(/.html$/, '.js');
          if (!fs.existsSync(src) || aux.newer(desv, mtime)) {
            continue;
          }
          code = fs.readFileSync(src).toString();
          try {
            t1 = Date.now();
            if (/^\/\/- ?module ?/.exec(code)) {
              continue;
            }
            desvdir = path.dirname(desv);
            fsExtra.ensureDirSync(desvdir);
            ret = pug.compileClient(code, import$({
              filename: src,
              basedir: this$.srcdir
            }, this$.extapi));
            ret = " (function() { " + ret + "; module.exports = template; })() ";
            fs.writeFileSync(desv, ret);
            t2 = Date.now();
            this$.log.info("[BUILD] " + src + " --> " + desv + " ( " + (t2 - t1) + "ms )");
            if (!/^\/\/- ?view ?/.exec(code)) {
              desdir = path.dirname(desh);
              fsExtra.ensureDirSync(desdir);
              fs.writeFileSync(desh, pug.render(code, import$({
                filename: src,
                basedir: this$.srcdir
              }, this$.extapi)));
              t2 = Date.now();
              results$.push(this$.log.info("[BUILD] " + src + " --> " + desh + " ( " + (t2 - t1) + "ms )"));
            }
          } catch (e$) {
            e = e$;
            this$.log.error(("[BUILD] " + src + " failed: ").red);
            results$.push(this$.log.error(e.message.toString().red));
          }
        }
        return results$;
      });
    };
    lngs = [''].concat(this.i18n
      ? ((ref$ = this.i18n).options || (ref$.options = {})).lng || []
      : []);
    consume = function(i){
      i == null && (i = 0);
      if (i >= lngs.length) {
        return;
      }
      return _(lngs[i]).then(function(){
        return consume(i + 1);
      });
    };
    return consume();
  }
});
/*
pugbuild = (opt={}) ->
  @opt = opt
  @log = opt.logger or aux.logger
  @i18n = opt.i18n or null
  @base = opt.base or '.'
  @intlbase = opt.intlbase or 'intl'
  @srcdir = path.normalize(path.join(@base, opt.srcdir or 'src/pug'))
  @desdir = path.normalize(path.join(@base, opt.desdir or 'static'))
  @viewdir = path.normalize(path.join(@base, opt.viewdir or '.view'))
  @extapi = @get-extapi!
  @adapter = new adapter do
    base: @srcdir

    build: (files) ~> @build files
  @adapter.init!
  @

pugbuild.prototype = Object.create(Object.prototype) <<< do
  get-adapter: -> @adapter
  resolve: (fn,src,opt) ->
    if !/^@/.exec(fn) => return path.resolve(path.join(path.dirname(src), fn))
    try
      if /^@\//.exec(fn) =>
        return require.resolve(fn.replace /^@\//, "")
      else if /^@static\//.exec(fn) =>
        des = "/" + path.join(@srcdir.split('/').filter(->it).map(-> '..').join('/'), @desdir)
        return path.resolve(path.join(path.dirname(src), fn.replace(/^@static/,des)))
    catch e
      throw new Error("no such file or directory: #fn")

  get-extapi: ->
    do
      plugins: [{resolve: (...args) ~> @resolve.apply @, args}]
      filters: do
        'lsc': (text, opt) -> return livescript.compile(text,{bare:true,header:false})
        'lson': (text, opt) -> return livescript.compile(text,{bare:true,header:false,json:true})
        'stylus': (text, opt) ->
           stylus(text)
             .set \filename, 'inline'
             .define 'index', (a,b) ->
               a = (a.string or a.val).split(' ')
               return new stylus.nodes.Unit(a.indexOf b.val)
             .render!
        'md': (text, opt) -> marked text
      md: marked
      yaml: -> js-yaml.safe-load fs.read-file-sync it
      yamls: (dir) ->
        ret = fs.readdir-sync dir
          .map -> "#dir/#it"
          .filter -> /\.yaml$/.exec(it)
          .map ->
            try
              js-yaml.safe-load(fs.read-file-sync it)
            catch e
              console.log "[ERROR@#it]: ", e
        return ret


  build: (files) ->
    _ = (lng = '') ~>
      intl = if lng => path.join(@intlbase,lng) else ''
      p = if @i18n and @i18n.changeLanguage =>
        @i18n.changeLanguage(if lng => that else @i18n.{}options.fallbackLng)
      else Promise.resolve!
      p.then ~>
        for {file, mtime} in files =>
          src = file
          desh = src.replace(@srcdir, @desdir).replace(/.pug$/, '.html')
          desv = desh.replace(@desdir, @viewdir).replace(/.html$/, '.js')
          if !fs.exists-sync(src) or aux.newer(desv, mtime) => continue
          code = fs.read-file-sync src .toString!
          try
            t1 = Date.now!
            if /^\/\/- ?module ?/.exec(code) => continue
            desvdir = path.dirname(desv)
            fs-extra.ensure-dir-sync desvdir
            ret = pug.compileClient code, {filename: src, basedir: @srcdir} <<< @extapi
            ret = """ (function() { #ret; module.exports = template; })() """
            fs.write-file-sync desv, ret
            t2 = Date.now!
            @log.info "[BUILD] #src --> #desv ( #{t2 - t1}ms )"
            if !(/^\/\/- ?view ?/.exec(code)) =>
              desdir = path.dirname(desh)
              fs-extra.ensure-dir-sync desdir
              fs.write-file-sync(
                desh, pug.render code, {filename: src, basedir: @srcdir} <<< @extapi
              )
              t2 = Date.now!
              @log.info "[BUILD] #src --> #desh ( #{t2 - t1}ms )"
          catch
            @log.error "[BUILD] #src failed: ".red
            @log.error e.message.toString!red


    lngs = ([''] ++ (if @i18n => @i18n.{}options.lng or [] else []))
    consume = (i = 0) ->
      if i >= lngs.length => return
      _(lngs[i]).then -> consume(i + 1)
    consume!

*/
module.exports = pugbuild;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}